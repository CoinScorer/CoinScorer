{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CoinScorer development documentation This site contains internal documentation for the CoinScorer development.","title":"CoinScorer development documentation"},{"location":"#coinscorer-development-documentation","text":"This site contains internal documentation for the CoinScorer development.","title":"CoinScorer development documentation"},{"location":"application_architecture/modules-architecture/","text":"Modules architecture Every module contains standalone logic for part of the application. Module Directory structure Module directory located in Modules \\ ModuleName . Content of Modules \\ ModuleName directory: Controller \\ Gui \\ Logic \\ Module \\ OrmModel \\ Storage \\ -- todo Tasks \\ Views \\ moduleNameModule.h moduleNameModule.cpp moduleNameDefs.h moduleNameStructs.h moduleNameTheme.h #ORM moduleName.module.xml moduleName.orm.xml Controllers Main access point to module logic. Accessed from Dialogs, MainWindows or other Controllers. Controllers using data from Views , calling Logic and storing data in Storage . Content of Modules \\ ModuleName \\ Controller structure: Controller \\ Controller \\i ModuleNameController.h Controller \\i ModuleNameDataController.h Controller \\m oduleNameController.h ( cpp ) Controller \\m oduleNameDataController.h ( cpp ) Logic All logic components of the module. Content of Modules \\ ModuleName \\ Logic structure: ComponentName \\ ComponentName \\C omponentPartName \\ ComponentName \\C omponentPartName \\c omponentPartName.h ComponentName \\C omponentPartName \\c omponentPartName.cpp ComponentName \\c omponentName.h ComponentName \\c omponentNameMB.h moduleNameLogic.pri Storage TODO - procistit adresar, procistit tridy Views Logic to create DataPack views from inner components data. Mostly quering and formating logic from datastructures to unified DataPack format. Views \\ Views \\m oduleNameView.h Views \\m oduleNameView.cpp Views \\m oduleNameView.test.cpp Base modules structure All shared logic is placed in Modules \\ Base directory. Base \\L ogic TODO: - baseModule - baseMbModule - base task - base met task - base logic component Content of Modules \\ Base \\ Logic structure: Base \\L ogic \\m oduleComponentBase.h Base \\L ogic \\m oduleComponentMessageBrokerBridge.h Component architecture In module: Manager -> Is Using MB for accessign data from other modules ^ Logic -> is using IManager to access local and remote data via MB, Logic doesn't use BM, Manager doesn't use remote managers but, for example in tradeAnalyzer, in logic, it's better to use ICurrencyManager than calling all MB. it's because we don't need full paralel processing there","title":"Modules architecture"},{"location":"application_architecture/modules-architecture/#modules-architecture","text":"Every module contains standalone logic for part of the application.","title":"Modules architecture"},{"location":"application_architecture/modules-architecture/#module-directory-structure","text":"Module directory located in Modules \\ ModuleName . Content of Modules \\ ModuleName directory: Controller \\ Gui \\ Logic \\ Module \\ OrmModel \\ Storage \\ -- todo Tasks \\ Views \\ moduleNameModule.h moduleNameModule.cpp moduleNameDefs.h moduleNameStructs.h moduleNameTheme.h #ORM moduleName.module.xml moduleName.orm.xml","title":"Module Directory structure"},{"location":"application_architecture/modules-architecture/#controllers","text":"Main access point to module logic. Accessed from Dialogs, MainWindows or other Controllers. Controllers using data from Views , calling Logic and storing data in Storage . Content of Modules \\ ModuleName \\ Controller structure: Controller \\ Controller \\i ModuleNameController.h Controller \\i ModuleNameDataController.h Controller \\m oduleNameController.h ( cpp ) Controller \\m oduleNameDataController.h ( cpp )","title":"Controllers"},{"location":"application_architecture/modules-architecture/#logic","text":"All logic components of the module. Content of Modules \\ ModuleName \\ Logic structure: ComponentName \\ ComponentName \\C omponentPartName \\ ComponentName \\C omponentPartName \\c omponentPartName.h ComponentName \\C omponentPartName \\c omponentPartName.cpp ComponentName \\c omponentName.h ComponentName \\c omponentNameMB.h moduleNameLogic.pri","title":"Logic"},{"location":"application_architecture/modules-architecture/#storage","text":"TODO - procistit adresar, procistit tridy","title":"Storage"},{"location":"application_architecture/modules-architecture/#views","text":"Logic to create DataPack views from inner components data. Mostly quering and formating logic from datastructures to unified DataPack format. Views \\ Views \\m oduleNameView.h Views \\m oduleNameView.cpp Views \\m oduleNameView.test.cpp","title":"Views"},{"location":"application_architecture/modules-architecture/#base-modules-structure","text":"All shared logic is placed in Modules \\ Base directory. Base \\L ogic TODO: - baseModule - baseMbModule - base task - base met task - base logic component Content of Modules \\ Base \\ Logic structure: Base \\L ogic \\m oduleComponentBase.h Base \\L ogic \\m oduleComponentMessageBrokerBridge.h","title":"Base modules structure"},{"location":"application_architecture/modules-architecture/#component-architecture","text":"In module: Manager -> Is Using MB for accessign data from other modules ^ Logic -> is using IManager to access local and remote data via MB, Logic doesn't use BM, Manager doesn't use remote managers but, for example in tradeAnalyzer, in logic, it's better to use ICurrencyManager than calling all MB. it's because we don't need full paralel processing there","title":"Component architecture"},{"location":"message_broker/architecture/","text":"Architecture Components: Exchange online data Realtime data from exchanges Exchange history data History data from exchanges Exchange cache Cached historic data from exchanges stored in local storage. Also caching latest candle price. Exchange candle splitter (concept only) Instead of downloading several timeframes from exchange, allow download only one stream and split it to several timeframes on local side. Indicators Realtime calculated indicators from exchange streams.","title":"Architecture"},{"location":"message_broker/architecture/#architecture","text":"Components:","title":"Architecture"},{"location":"message_broker/architecture/#exchange-online-data","text":"Realtime data from exchanges","title":"Exchange online data"},{"location":"message_broker/architecture/#exchange-history-data","text":"History data from exchanges","title":"Exchange history data"},{"location":"message_broker/architecture/#exchange-cache","text":"Cached historic data from exchanges stored in local storage. Also caching latest candle price.","title":"Exchange cache"},{"location":"message_broker/architecture/#exchange-candle-splitter-concept-only","text":"Instead of downloading several timeframes from exchange, allow download only one stream and split it to several timeframes on local side.","title":"Exchange candle splitter (concept only)"},{"location":"message_broker/architecture/#indicators","text":"Realtime calculated indicators from exchange streams.","title":"Indicators"},{"location":"message_broker/exchange-alerts/","text":"Exchange Alerts Alert notification Type: Message Message: MessageType::ExchangeAlerts::onNotify(uuid) Params: timestamp_t timestamp Send SendMessage ( MessageType :: ExchangeAlerts :: onNotify ( uuidAlert ), tmTimestamp ); Register RegisterMessageCallback < timestamp_t > ( MessageType :: ExchangeAlerts :: onNotify ( uuid ), boost :: bind ( & method , this , _1 ) ); Handler void method ( timestamp_t tmTimestamp ) { }","title":"Exchange Alerts"},{"location":"message_broker/exchange-alerts/#exchange-alerts","text":"","title":"Exchange Alerts"},{"location":"message_broker/exchange-alerts/#alert-notification","text":"Type: Message Message: MessageType::ExchangeAlerts::onNotify(uuid) Params: timestamp_t timestamp Send SendMessage ( MessageType :: ExchangeAlerts :: onNotify ( uuidAlert ), tmTimestamp ); Register RegisterMessageCallback < timestamp_t > ( MessageType :: ExchangeAlerts :: onNotify ( uuid ), boost :: bind ( & method , this , _1 ) ); Handler void method ( timestamp_t tmTimestamp ) { }","title":"Alert notification"},{"location":"message_broker/exchange-api-keys/","text":"Exchange Api Keys Notification of API key change Type: Message Message: MessageType::ExchangeApiKeys::notifyApiKeyEvent Params: const XUuid& uuidApiKey, EnmApiKeyAction action Send SendMessage < XString , stAccountState > ( MessageType :: ExchangeApiKeys :: notifyApiKeyEvent ` :: id (), uuidApiKey , action , ); Register RegisterMessageCallback < XString , stAccountState > ( MessageType :: ExchangeApiKeys :: notifyApiKeyEvent ` :: id (), boost :: bind ( & method , this , _1 , _2 ) ); Handler void method ( const XUuid & uuidApiKey , EnmApiKeyAction action ) { }","title":"Exchange Api Keys"},{"location":"message_broker/exchange-api-keys/#exchange-api-keys","text":"","title":"Exchange Api Keys"},{"location":"message_broker/exchange-api-keys/#notification-of-api-key-change","text":"Type: Message Message: MessageType::ExchangeApiKeys::notifyApiKeyEvent Params: const XUuid& uuidApiKey, EnmApiKeyAction action Send SendMessage < XString , stAccountState > ( MessageType :: ExchangeApiKeys :: notifyApiKeyEvent ` :: id (), uuidApiKey , action , ); Register RegisterMessageCallback < XString , stAccountState > ( MessageType :: ExchangeApiKeys :: notifyApiKeyEvent ` :: id (), boost :: bind ( & method , this , _1 , _2 ) ); Handler void method ( const XUuid & uuidApiKey , EnmApiKeyAction action ) { }","title":"Notification of API key change"},{"location":"message_broker/exchange-assets/","text":"Exchange Assets Request asset state on account Type: Request Message: MessageType::ExchangeAssets::requestGetAccountState Returns: stAccountState Params: XUuid apiKey, XString strAsset Send SendRequest < stAccountState , XUuid , XString > ( MessageType :: ExchangeAssets :: requestGetAccountState :: id (), apiKey , \"BTC\" ); Register RegisterRequestCallback < stAccountState , XUuid , XString > ( MessageType :: ExchangeAssets :: requestGetAccountState :: id (), boost :: bind ( & method , this , _1 , _2 ) ); Handler stAccountState method ( const XUuid & apiKey , const XString & strAsset ) { } Notification of asset change on API account Type: Message Message: MessageType::ExchangeAssets::notifyAccountAssetChanged Params: XString strApiKey, const stAccountState& accountState Send SendMessage < XString , stAccountState > ( MessageType :: ExchangeAssets :: notifyAccountAssetChanged ` :: id (), strApiKey , accountState , ); Register RegisterMessageCallback < XString , stAccountState > ( MessageType :: ExchangeAssets :: notifyAccountAssetChanged ` :: id (), boost :: bind ( & method , this , _1 , _2 ) ); Handler void method ( const XString & strApiKey , const Modules :: Currencies :: stAccountState & accountState ) { }","title":"Exchange Assets"},{"location":"message_broker/exchange-assets/#exchange-assets","text":"","title":"Exchange Assets"},{"location":"message_broker/exchange-assets/#request-asset-state-on-account","text":"Type: Request Message: MessageType::ExchangeAssets::requestGetAccountState Returns: stAccountState Params: XUuid apiKey, XString strAsset Send SendRequest < stAccountState , XUuid , XString > ( MessageType :: ExchangeAssets :: requestGetAccountState :: id (), apiKey , \"BTC\" ); Register RegisterRequestCallback < stAccountState , XUuid , XString > ( MessageType :: ExchangeAssets :: requestGetAccountState :: id (), boost :: bind ( & method , this , _1 , _2 ) ); Handler stAccountState method ( const XUuid & apiKey , const XString & strAsset ) { }","title":"Request asset state on account"},{"location":"message_broker/exchange-assets/#notification-of-asset-change-on-api-account","text":"Type: Message Message: MessageType::ExchangeAssets::notifyAccountAssetChanged Params: XString strApiKey, const stAccountState& accountState Send SendMessage < XString , stAccountState > ( MessageType :: ExchangeAssets :: notifyAccountAssetChanged ` :: id (), strApiKey , accountState , ); Register RegisterMessageCallback < XString , stAccountState > ( MessageType :: ExchangeAssets :: notifyAccountAssetChanged ` :: id (), boost :: bind ( & method , this , _1 , _2 ) ); Handler void method ( const XString & strApiKey , const Modules :: Currencies :: stAccountState & accountState ) { }","title":"Notification of asset change on API account"},{"location":"message_broker/exchange-cache/","text":"Exchange Cache Request/Demand cached exchange data by interval Type: Request/Demand Message: MessageType::ExchangeDataCache::demandGetCachedExchangeDataByInterval Returns: candleData : XCandlesGapContainerSimple Params: stExchangeId exchangeId, const stSymbolPair& symbol, TTimeframe timeframe, TTimestampInterval dataInterval Send SendDemand < XCandlesGapContainerSimple , stExchangeId , stSymbolPair , TTimeframe , TTimestampInterval > ( MessageType :: ExchangeDataCache :: demandGetCachedExchangeDataByInterval :: id (), boost :: bind ( & method , this , _1 ), exchange , symbol , timeframe , interval ); Register RegisterDemandCallback < XCandlesGapContainerSimple , stExchangeId , stSymbolPair , TTimeframe , TTimestampInterval > ( MessageType :: ExchangeDataCache :: demandGetCachedExchangeDataByInterval :: id (), boost :: bind ( & method , this , _1 , _2 , _3 , _4 , _5 ) ); Handler void method ( Atomix :: MessageBroker :: IDemandEvent < XCandlesGapContainerSimple >* demandEvent , const stExchangeId & exchangeId , const Modules :: Currencies :: stSymbolPair & pair , const TTimeframe & tfTimeframe , const TTimestampInterval & tmTimeInterval ) { } Request/Demand cached exchange data by amount Type: Request/Demand Message: MessageType::ExchangeDataCache::demandGetCachedExchangeDataByAmount Returns: candleData : XCandlesGapContainerSimple Params: stExchangeId exchangeId, const stSymbolPair& symbol, TTimeframe timeframe, TTimestamp dataTimestamp, int nAmount Note: Requires amount data starting by dataTimestamp. For forward pass +amount , for backward -amount Send SendDemand < XCandlesGapContainerSimple , stExchangeId , stSymbolPair , TTimeframe , TTimestamp , int > ( MessageType :: ExchangeDataCache :: demandGetCachedExchangeDataByAmount :: id (), boost :: bind ( & method , this , _1 ), exchange , symbol , timestamp , amount ); Register RegisterDemandCallback < XCandlesGapContainerSimple , stExchangeId , stSymbolPair , TTimeframe , TTimestamp , int > ( MessageType :: ExchangeDataCache :: demandGetCachedExchangeDataByAmount :: id (), boost :: bind ( & method , this , _1 , _2 , _3 , _4 , _5 , _6 ) ); Handler void method ( Atomix :: MessageBroker :: IDemandEvent < XCandlesGapContainerSimple >* demandEvent , const stExchangeId & exchangeId , const Modules :: Currencies :: stSymbolPair & pair , const TTimeframe & tfTimeframe , const TTimestamp & tmTimeInterval , int nAmount ) { } Request/Demand prepare cache of multiple symbols Type: Message Message: MessageType::ExchangeDataCache::messagePrecacheExchangeDataMultiple Params: XLstExchangeDataRequests requestData Send SendMessage < XLstExchangeDataRequests > ( MessageType :: ExchangeDataCache :: messagePrecacheExchangeDataMultiple :: id (), requestData ); Register RegisterMessageCallback < XLstExchangeDataRequests > ( MessageType :: ExchangeDataCache :: messagePrecacheExchangeDataMultiple :: id (), boost :: bind ( & method , this , _1 ) ); Handler void method ( XLstExchangeDataRequests requestData ) { }","title":"Exchange Cache"},{"location":"message_broker/exchange-cache/#exchange-cache","text":"","title":"Exchange Cache"},{"location":"message_broker/exchange-cache/#requestdemand-cached-exchange-data-by-interval","text":"Type: Request/Demand Message: MessageType::ExchangeDataCache::demandGetCachedExchangeDataByInterval Returns: candleData : XCandlesGapContainerSimple Params: stExchangeId exchangeId, const stSymbolPair& symbol, TTimeframe timeframe, TTimestampInterval dataInterval Send SendDemand < XCandlesGapContainerSimple , stExchangeId , stSymbolPair , TTimeframe , TTimestampInterval > ( MessageType :: ExchangeDataCache :: demandGetCachedExchangeDataByInterval :: id (), boost :: bind ( & method , this , _1 ), exchange , symbol , timeframe , interval ); Register RegisterDemandCallback < XCandlesGapContainerSimple , stExchangeId , stSymbolPair , TTimeframe , TTimestampInterval > ( MessageType :: ExchangeDataCache :: demandGetCachedExchangeDataByInterval :: id (), boost :: bind ( & method , this , _1 , _2 , _3 , _4 , _5 ) ); Handler void method ( Atomix :: MessageBroker :: IDemandEvent < XCandlesGapContainerSimple >* demandEvent , const stExchangeId & exchangeId , const Modules :: Currencies :: stSymbolPair & pair , const TTimeframe & tfTimeframe , const TTimestampInterval & tmTimeInterval ) { }","title":"Request/Demand cached exchange data by interval"},{"location":"message_broker/exchange-cache/#requestdemand-cached-exchange-data-by-amount","text":"Type: Request/Demand Message: MessageType::ExchangeDataCache::demandGetCachedExchangeDataByAmount Returns: candleData : XCandlesGapContainerSimple Params: stExchangeId exchangeId, const stSymbolPair& symbol, TTimeframe timeframe, TTimestamp dataTimestamp, int nAmount Note: Requires amount data starting by dataTimestamp. For forward pass +amount , for backward -amount Send SendDemand < XCandlesGapContainerSimple , stExchangeId , stSymbolPair , TTimeframe , TTimestamp , int > ( MessageType :: ExchangeDataCache :: demandGetCachedExchangeDataByAmount :: id (), boost :: bind ( & method , this , _1 ), exchange , symbol , timestamp , amount ); Register RegisterDemandCallback < XCandlesGapContainerSimple , stExchangeId , stSymbolPair , TTimeframe , TTimestamp , int > ( MessageType :: ExchangeDataCache :: demandGetCachedExchangeDataByAmount :: id (), boost :: bind ( & method , this , _1 , _2 , _3 , _4 , _5 , _6 ) ); Handler void method ( Atomix :: MessageBroker :: IDemandEvent < XCandlesGapContainerSimple >* demandEvent , const stExchangeId & exchangeId , const Modules :: Currencies :: stSymbolPair & pair , const TTimeframe & tfTimeframe , const TTimestamp & tmTimeInterval , int nAmount ) { }","title":"Request/Demand cached exchange data by amount"},{"location":"message_broker/exchange-cache/#requestdemand-prepare-cache-of-multiple-symbols","text":"Type: Message Message: MessageType::ExchangeDataCache::messagePrecacheExchangeDataMultiple Params: XLstExchangeDataRequests requestData Send SendMessage < XLstExchangeDataRequests > ( MessageType :: ExchangeDataCache :: messagePrecacheExchangeDataMultiple :: id (), requestData ); Register RegisterMessageCallback < XLstExchangeDataRequests > ( MessageType :: ExchangeDataCache :: messagePrecacheExchangeDataMultiple :: id (), boost :: bind ( & method , this , _1 ) ); Handler void method ( XLstExchangeDataRequests requestData ) { }","title":"Request/Demand prepare cache of multiple symbols"},{"location":"message_broker/exchange-candle-splitter/","text":"Exchange Candle Splitter Idea is to receive only one stream per exchange/symbol (probably 1minute or via trades) and calculate all timeframes on local side. Candle Ticker start/stop Type: Message Start: MessageType::ExchangeCandleSplitter::cmdCandleTickerMultiStart Stop: MessageType::ExchangeCandleSplitter::cmdCandleTickerMultiStop Params: XString strExchange, const TlstSymbolPairs& symbol, TTimeframe timeframe Send SendMessage < XString , TlstSymbolPairs , TTimeframe > ( MessageType :: ExchangeCandleSplitter :: cmdCandleTickerMultiStart :: id (), \"binance\" , { stSymbolPair ( \"bnb\" , \"btc\" ), stSymbolPair ( \"btc\" , \"usdt\" ) }, TTimeframe ( EnmTimeframe :: Min1 ) ); SendMessage < XString , TlstSymbolPairs , TTimeframe > ( MessageType :: ExchangeCandleSplitter :: cmdCandleTickerMultiStop :: id (), \"binance\" , { stSymbolPair ( \"bnb\" , \"btc\" ), stSymbolPair ( \"btc\" , \"usdt\" ) }, TTimeframe ( EnmTimeframe :: Min1 ) ); Register RegisterMessageCallback < XString , Currencies :: TlstSymbolPairs , TTimeframe > ( MessageType :: ExchangeCandleSplitter :: cmdCandleTickerMultiStart :: id (), boost :: bind ( & method , this , _1 , _2 , _3 ) ); RegisterMessageCallback < XString , Currencies :: TlstSymbolPairs , TTimeframe > ( MessageType :: ExchangeCandleSplitter :: cmdCandleTickerMultiStop :: id (), boost :: bind ( & method , this , _1 , _2 , _3 ) ); Prepare candle storage Type: Message Message: MessageType::Storage::cmdStoragePrepare Message: MessageType::Storage::cmdStorageMultiPrepare Params: XString strExchange, const stSymbolPair& symbol, TTimeframe timeframe Params: XString strExchange, const TlstSymbolPairs& symbol, TTimeframe timeframe Send SendMessage < XString , stSymbolPair , TTimeframe > ( ExchangesData :: MessageType :: Storage :: cmdStoragePrepare :: id (), exchange , symbol , timeframe ); SendMessage < XString , TlstSymbolPairs , TTimeframe > ( ExchangesData :: MessageType :: Storage :: cmdStoragePrepare :: id (), exchange , symbol , timeframe ); Register RegisterMessageCallback < XString , stSymbolPair , TTimeframe > ( MessageType :: Storage :: cmdStoragePrepare :: id (), boost :: bind ( & method , this , _1 , _2 , _3 ) ); RegisterMessageCallback < XString , TlstSymbolPairs , TTimeframe > ( MessageType :: Storage :: cmdStorageMultiPrepare :: id (), boost :: bind ( & method , this , _1 , _2 , _3 ) ); Request latest price Type: Request Message: MessageType::Storage::requestLatestPrice Returns: timeCandleStick : stTimeCandleStick Params: XString strExchange, const stSymbolPair& symbol Send SendRequest < stTimeCandleStick > ( MessageType :: Storage :: requestLatestPrice :: id (), exchange , symbol ); Register RegisterRequestCallback < stTimeCandleStick , XString , stSymbolPair > ( MessageType :: Storage :: requestLatestPrice :: id (), boost :: bind ( & method , this , _1 , _2 ) ); Request known pairs Type: Request Message: MessageType::Storage::requestKnownPairs Returns: timeCandleStick : stTimeCandleStick Params: XString strExchange Send SendRequest < TlstSymbolPairs , XString > ( Modules :: ExchangesData :: MessageType :: Storage :: requestKnownPairs :: id (), exchange ); Register RegisterRequestCallback < TlstSymbolPairs , XString > ( MessageType :: Storage :: requestKnownPairs :: id (), boost :: bind ( & method , this , _1 ) ); Demand storage data Type: Demand Message: MessageType::Storage::requestKnownPairs Returns: candleData : XCandlesGapContainerSimple Params: XString strExchange, const stSymbolPair& symbol, TTimeframe timeframe, TTimestampInterval dataInterval Send SendDemand < XCandlesGapContainerSimple , XString , stSymbolPair , TTimeframe , TTimestampInterval > ( MessageType :: Storage :: demandStorageGetData :: id (), boost :: bind ( & method , this , _1 ), exchange , symbol , timeframe , interval ); Register RegisterDemandCallback < XCandlesGapContainerSimple , XString , stSymbolPair , TTimeframe , TTimestampInterval > ( MessageType :: Storage :: demandStorageGetData :: id (), boost :: bind ( & method , this , _1 , _2 , _3 , _4 , _5 ) ); Storage Candle tick Notifies that calculated symbol in storage was updated Type: Message Message: MessageType::Storage::onCandleTick(exchange, symbol,timeframe) Params: const stTimeCandleStick& timeCandle Send SendMessage < stTimeCandleStick > ( MessageType :: Storage :: onCandleTick ( exchange , symbol , timeframe ), timeCandleStick ); Register RegisterMessageCallback < stTimeCandleStick > ( MessageType :: Storage :: onCandleTick ( exchange , symbol , timeframe ), boost :: bind ( & method , this , _1 ) ); Candles updated in storage Notifies that all calculated candles were updated (instead of listening several timeframes, storage will listen one data stream and calculate all others 1m -> 5m,10m,...) Type: Message Message: MessageType::Storage::onCandleUpdated(exchange, symbol,timeframe) Params: originalCandle : stTimeCandleStick Send SendMessage < stTimeCandleStick > ( MessageType :: Storage :: onCandleUpdated ( exchange , symbol , timeframe ), timeCandleStick ); Register RegisterMessageCallback < stTimeCandleStick > ( MessageType :: Storage :: onCandleUpdated ( exchange , symbol , timeframe ), boost :: bind ( & method , this , _1 ) );","title":"Exchange Candle Splitter"},{"location":"message_broker/exchange-candle-splitter/#exchange-candle-splitter","text":"Idea is to receive only one stream per exchange/symbol (probably 1minute or via trades) and calculate all timeframes on local side.","title":"Exchange Candle Splitter"},{"location":"message_broker/exchange-candle-splitter/#candle-ticker-startstop","text":"Type: Message Start: MessageType::ExchangeCandleSplitter::cmdCandleTickerMultiStart Stop: MessageType::ExchangeCandleSplitter::cmdCandleTickerMultiStop Params: XString strExchange, const TlstSymbolPairs& symbol, TTimeframe timeframe Send SendMessage < XString , TlstSymbolPairs , TTimeframe > ( MessageType :: ExchangeCandleSplitter :: cmdCandleTickerMultiStart :: id (), \"binance\" , { stSymbolPair ( \"bnb\" , \"btc\" ), stSymbolPair ( \"btc\" , \"usdt\" ) }, TTimeframe ( EnmTimeframe :: Min1 ) ); SendMessage < XString , TlstSymbolPairs , TTimeframe > ( MessageType :: ExchangeCandleSplitter :: cmdCandleTickerMultiStop :: id (), \"binance\" , { stSymbolPair ( \"bnb\" , \"btc\" ), stSymbolPair ( \"btc\" , \"usdt\" ) }, TTimeframe ( EnmTimeframe :: Min1 ) ); Register RegisterMessageCallback < XString , Currencies :: TlstSymbolPairs , TTimeframe > ( MessageType :: ExchangeCandleSplitter :: cmdCandleTickerMultiStart :: id (), boost :: bind ( & method , this , _1 , _2 , _3 ) ); RegisterMessageCallback < XString , Currencies :: TlstSymbolPairs , TTimeframe > ( MessageType :: ExchangeCandleSplitter :: cmdCandleTickerMultiStop :: id (), boost :: bind ( & method , this , _1 , _2 , _3 ) );","title":"Candle Ticker start/stop"},{"location":"message_broker/exchange-candle-splitter/#prepare-candle-storage","text":"Type: Message Message: MessageType::Storage::cmdStoragePrepare Message: MessageType::Storage::cmdStorageMultiPrepare Params: XString strExchange, const stSymbolPair& symbol, TTimeframe timeframe Params: XString strExchange, const TlstSymbolPairs& symbol, TTimeframe timeframe Send SendMessage < XString , stSymbolPair , TTimeframe > ( ExchangesData :: MessageType :: Storage :: cmdStoragePrepare :: id (), exchange , symbol , timeframe ); SendMessage < XString , TlstSymbolPairs , TTimeframe > ( ExchangesData :: MessageType :: Storage :: cmdStoragePrepare :: id (), exchange , symbol , timeframe ); Register RegisterMessageCallback < XString , stSymbolPair , TTimeframe > ( MessageType :: Storage :: cmdStoragePrepare :: id (), boost :: bind ( & method , this , _1 , _2 , _3 ) ); RegisterMessageCallback < XString , TlstSymbolPairs , TTimeframe > ( MessageType :: Storage :: cmdStorageMultiPrepare :: id (), boost :: bind ( & method , this , _1 , _2 , _3 ) );","title":"Prepare candle storage"},{"location":"message_broker/exchange-candle-splitter/#request-latest-price","text":"Type: Request Message: MessageType::Storage::requestLatestPrice Returns: timeCandleStick : stTimeCandleStick Params: XString strExchange, const stSymbolPair& symbol Send SendRequest < stTimeCandleStick > ( MessageType :: Storage :: requestLatestPrice :: id (), exchange , symbol ); Register RegisterRequestCallback < stTimeCandleStick , XString , stSymbolPair > ( MessageType :: Storage :: requestLatestPrice :: id (), boost :: bind ( & method , this , _1 , _2 ) );","title":"Request latest price"},{"location":"message_broker/exchange-candle-splitter/#request-known-pairs","text":"Type: Request Message: MessageType::Storage::requestKnownPairs Returns: timeCandleStick : stTimeCandleStick Params: XString strExchange Send SendRequest < TlstSymbolPairs , XString > ( Modules :: ExchangesData :: MessageType :: Storage :: requestKnownPairs :: id (), exchange ); Register RegisterRequestCallback < TlstSymbolPairs , XString > ( MessageType :: Storage :: requestKnownPairs :: id (), boost :: bind ( & method , this , _1 ) );","title":"Request known pairs"},{"location":"message_broker/exchange-candle-splitter/#demand-storage-data","text":"Type: Demand Message: MessageType::Storage::requestKnownPairs Returns: candleData : XCandlesGapContainerSimple Params: XString strExchange, const stSymbolPair& symbol, TTimeframe timeframe, TTimestampInterval dataInterval Send SendDemand < XCandlesGapContainerSimple , XString , stSymbolPair , TTimeframe , TTimestampInterval > ( MessageType :: Storage :: demandStorageGetData :: id (), boost :: bind ( & method , this , _1 ), exchange , symbol , timeframe , interval ); Register RegisterDemandCallback < XCandlesGapContainerSimple , XString , stSymbolPair , TTimeframe , TTimestampInterval > ( MessageType :: Storage :: demandStorageGetData :: id (), boost :: bind ( & method , this , _1 , _2 , _3 , _4 , _5 ) );","title":"Demand storage data"},{"location":"message_broker/exchange-candle-splitter/#storage-candle-tick","text":"Notifies that calculated symbol in storage was updated Type: Message Message: MessageType::Storage::onCandleTick(exchange, symbol,timeframe) Params: const stTimeCandleStick& timeCandle Send SendMessage < stTimeCandleStick > ( MessageType :: Storage :: onCandleTick ( exchange , symbol , timeframe ), timeCandleStick ); Register RegisterMessageCallback < stTimeCandleStick > ( MessageType :: Storage :: onCandleTick ( exchange , symbol , timeframe ), boost :: bind ( & method , this , _1 ) );","title":"Storage Candle tick"},{"location":"message_broker/exchange-candle-splitter/#candles-updated-in-storage","text":"Notifies that all calculated candles were updated (instead of listening several timeframes, storage will listen one data stream and calculate all others 1m -> 5m,10m,...) Type: Message Message: MessageType::Storage::onCandleUpdated(exchange, symbol,timeframe) Params: originalCandle : stTimeCandleStick Send SendMessage < stTimeCandleStick > ( MessageType :: Storage :: onCandleUpdated ( exchange , symbol , timeframe ), timeCandleStick ); Register RegisterMessageCallback < stTimeCandleStick > ( MessageType :: Storage :: onCandleUpdated ( exchange , symbol , timeframe ), boost :: bind ( & method , this , _1 ) );","title":"Candles updated in storage"},{"location":"message_broker/exchange-coins/","text":"Exchange Coins Request current symbol price Type: Request Message: MessageType::ExchangeCoins::requestSymbolPrice Returns: double Params: stExchangeId exchangeId, stSymbolPair symbol Send SendRequest < double , stExchangeId , stSymbolPair > ( MessageType :: ExchangeCoins :: requestSymbolPrice :: id (), \"binance\" , stSymbolPair ( \"btc\" , \"usdt\" ) ); Register RegisterRequestCallback < double , stExchangeId , stSymbolPair > ( MessageType :: ExchangeCoins :: requestSymbolPrice :: id (), boost :: bind ( & method , this , _1 , _2 ) ); Handler double method ( const stExchangeId & exchangeId , const stSymbolPair & symbol ) { } Request known pairs Type: Request Message: MessageType::ExchangeCoins::requestKnownPairs Returns: symbols : TlstSymbolPairs Params: stExchangeId exchangeId Send SendRequest < TlstSymbolPairs , stExchangeId > ( MessageType :: ExchangeCoins :: requestKnownPairs :: id (), \"binance\" ); Register RegisterRequestCallback < TlstSymbolPairs , stExchangeId > ( MessageType :: ExchangeCoins :: requestKnownPairs :: id (), boost :: bind ( & method , this , _1 ) ); Request market tickers with filter Type: Request Message: MessageType::ExchangeCoins::requestFilteredMarketTickers Returns: symbols : TlstSymbolPairs Params: stExchangeId exchangeId, stSymbolsFilterAdvanced filter Send SendRequest < TlstSymbolPairs , stExchangeId , timeframe_t > ( MessageType :: ExchangeCoins :: requestFilteredMarketTickers :: id (), \"binance\" , filter ); Register RegisterRequestCallback < TlstSymbolPairs , stExchangeId , stSymbolsFilterAdvanced > ( MessageType :: ExchangeCoins :: requestFilteredMarketTickers :: id (), boost :: bind ( & method , this , _1 , _2 ) ); Notification of new symbol Type: Message Message: MessageType::ExchangeCoins::notifyExchangeNewSymbol Params: const stExchangeId& exchangeId, const stSymbolPair& symbol Send SendMessage < stExchangeId , stSymbolPair > ( MessageType :: ExchangeCoins :: notifyExchangeNewSymbol :: id (), boost :: bind ( & method , this , _1 ), exchange , symbol , ); Register RegisterMessageCallback < stExchangeId , stSymbolPair > ( MessageType :: ExchangeCoins :: notifyExchangeNewSymbol :: id (), boost :: bind ( & method , this , _1 , _2 ) ); Handler void method ( const stExchangeId & exchangeId , const Modules :: Currencies :: stSymbolPair & pair ) { } Notification of exchange prices update Type: Message Message: MessageType::ExchangeCoins::notifyExchangePriceUpdated Params: const stExchangeId& exchangeId, const stMarketTicker& tickUpdate Send SendMessage < stExchangeId , stMarketTicker > ( MessageType :: ExchangeCoins :: notifyExchangePriceUpdated :: id (), boost :: bind ( & method , this , _1 ), exchange , ); Register RegisterMessageCallback < stExchangeId , stMarketTicker > ( MessageType :: ExchangeCoins :: notifyExchangePriceUpdated :: id (), boost :: bind ( & method , this , _1 ) ); Handler void method ( const stExchangeId & exchangeId , const stMarketTicker & tickUpdate ) { }","title":"Exchange Coins"},{"location":"message_broker/exchange-coins/#exchange-coins","text":"","title":"Exchange Coins"},{"location":"message_broker/exchange-coins/#request-current-symbol-price","text":"Type: Request Message: MessageType::ExchangeCoins::requestSymbolPrice Returns: double Params: stExchangeId exchangeId, stSymbolPair symbol Send SendRequest < double , stExchangeId , stSymbolPair > ( MessageType :: ExchangeCoins :: requestSymbolPrice :: id (), \"binance\" , stSymbolPair ( \"btc\" , \"usdt\" ) ); Register RegisterRequestCallback < double , stExchangeId , stSymbolPair > ( MessageType :: ExchangeCoins :: requestSymbolPrice :: id (), boost :: bind ( & method , this , _1 , _2 ) ); Handler double method ( const stExchangeId & exchangeId , const stSymbolPair & symbol ) { }","title":"Request current symbol price"},{"location":"message_broker/exchange-coins/#request-known-pairs","text":"Type: Request Message: MessageType::ExchangeCoins::requestKnownPairs Returns: symbols : TlstSymbolPairs Params: stExchangeId exchangeId Send SendRequest < TlstSymbolPairs , stExchangeId > ( MessageType :: ExchangeCoins :: requestKnownPairs :: id (), \"binance\" ); Register RegisterRequestCallback < TlstSymbolPairs , stExchangeId > ( MessageType :: ExchangeCoins :: requestKnownPairs :: id (), boost :: bind ( & method , this , _1 ) );","title":"Request known pairs"},{"location":"message_broker/exchange-coins/#request-market-tickers-with-filter","text":"Type: Request Message: MessageType::ExchangeCoins::requestFilteredMarketTickers Returns: symbols : TlstSymbolPairs Params: stExchangeId exchangeId, stSymbolsFilterAdvanced filter Send SendRequest < TlstSymbolPairs , stExchangeId , timeframe_t > ( MessageType :: ExchangeCoins :: requestFilteredMarketTickers :: id (), \"binance\" , filter ); Register RegisterRequestCallback < TlstSymbolPairs , stExchangeId , stSymbolsFilterAdvanced > ( MessageType :: ExchangeCoins :: requestFilteredMarketTickers :: id (), boost :: bind ( & method , this , _1 , _2 ) );","title":"Request market tickers with filter"},{"location":"message_broker/exchange-coins/#notification-of-new-symbol","text":"Type: Message Message: MessageType::ExchangeCoins::notifyExchangeNewSymbol Params: const stExchangeId& exchangeId, const stSymbolPair& symbol Send SendMessage < stExchangeId , stSymbolPair > ( MessageType :: ExchangeCoins :: notifyExchangeNewSymbol :: id (), boost :: bind ( & method , this , _1 ), exchange , symbol , ); Register RegisterMessageCallback < stExchangeId , stSymbolPair > ( MessageType :: ExchangeCoins :: notifyExchangeNewSymbol :: id (), boost :: bind ( & method , this , _1 , _2 ) ); Handler void method ( const stExchangeId & exchangeId , const Modules :: Currencies :: stSymbolPair & pair ) { }","title":"Notification of new symbol"},{"location":"message_broker/exchange-coins/#notification-of-exchange-prices-update","text":"Type: Message Message: MessageType::ExchangeCoins::notifyExchangePriceUpdated Params: const stExchangeId& exchangeId, const stMarketTicker& tickUpdate Send SendMessage < stExchangeId , stMarketTicker > ( MessageType :: ExchangeCoins :: notifyExchangePriceUpdated :: id (), boost :: bind ( & method , this , _1 ), exchange , ); Register RegisterMessageCallback < stExchangeId , stMarketTicker > ( MessageType :: ExchangeCoins :: notifyExchangePriceUpdated :: id (), boost :: bind ( & method , this , _1 ) ); Handler void method ( const stExchangeId & exchangeId , const stMarketTicker & tickUpdate ) { }","title":"Notification of exchange prices update"},{"location":"message_broker/exchange-historic-data/","text":"Exchange History Data Demand download historic data by interval Type: Demand Message: MessageType::ExchangeDataHistoric::demandDownloadHistoricDataByInterval Returns: candles : XCandlesGapContainerSimple Params: stExchangeId exchangeId, const stSymbolPair& symbol, TTimeframe timeframe, TTimestampInterval timeInterval, bool bReturnAllDownloadedData Send SendDemand < XCandlesGapContainerSimple , stExchangeId , stSymbolPair , TTimeframe , TTimestampInterval , bool > ( MessageType :: ExchangeDataHistoric :: demandDownloadHistoricDataByInterval :: id (), boost :: bind ( & method , this , _1 ), exchangeId , symbol , tfTimeframe , timestampInterval , bReturnAllDownloadedData ); Register RegisterDemandCallback < XCandlesGapContainerSimple , stExchangeId , stSymbolPair , TTimeframe , TTimestampInterval , bool > ( MessageType :: ExchangeDataHistoric :: demandDownloadHistoricDataByInterval :: id (), boost :: bind ( & method , this , _1 , _2 , _3 , _4 , _5 , _6 ) ); Handler void method ( Atomix :: MessageBroker :: IDemandEvent < XCandlesGapContainerSimple >* demandEvent , const stExchangeId & exchangeId , const Modules :: Currencies :: stSymbolPair & pair , const TTimeframe & tfTimeframe , const TTimestampInterval & tmTimeInterval , bool bReturnAllDownloadedData ) { } Demand download historic data by amount Type: Demand Message: MessageType::ExchangeDataHistoric::demandDownloadHistoricDataByAmount Returns: candles : XCandlesGapContainerSimple Params: stExchangeId exchangeId, const stSymbolPair& symbol, TTimeframe timeframe, TTimestamp timestmap, int nAmount, bool bReturnAllDownloadedData Note: Requires amount data starting by dataTimestamp. For forward pass +amount , for backward -amount Send SendDemand < XCandlesGapContainerSimple , stExchangeId , stSymbolPair , TTimeframe , TTimestamp , int , bool > ( MessageType :: ExchangeDataHistoric :: demandDownloadHistoricDataByAmount :: id (), boost :: bind ( & method , this , _1 ), exchangeId , symbol , tfTimeframe , timestamp , nAmount , bReturnAllDownloadedData ); Register RegisterDemandCallback < XCandlesGapContainerSimple , stExchangeId , stSymbolPair , TTimeframe , TTimestamp , int , bool > ( MessageType :: ExchangeDataHistoric :: demandDownloadHistoricDataByAmount :: id (), boost :: bind ( & method , this , _1 , _2 , _3 , _4 , _5 , _6 , _7 ) ); Handler void method ( Atomix :: MessageBroker :: IDemandEvent < XCandlesGapContainerSimple >* demandEvent , const stExchangeId & exchangeId , const Modules :: Currencies :: stSymbolPair & pair , const TTimeframe & tfTimeframe , const TTimestamp & tmTimestamp , int nAmount , bool bReturnAllDownloadedData ) { }","title":"Exchange History Data"},{"location":"message_broker/exchange-historic-data/#exchange-history-data","text":"","title":"Exchange History Data"},{"location":"message_broker/exchange-historic-data/#demand-download-historic-data-by-interval","text":"Type: Demand Message: MessageType::ExchangeDataHistoric::demandDownloadHistoricDataByInterval Returns: candles : XCandlesGapContainerSimple Params: stExchangeId exchangeId, const stSymbolPair& symbol, TTimeframe timeframe, TTimestampInterval timeInterval, bool bReturnAllDownloadedData Send SendDemand < XCandlesGapContainerSimple , stExchangeId , stSymbolPair , TTimeframe , TTimestampInterval , bool > ( MessageType :: ExchangeDataHistoric :: demandDownloadHistoricDataByInterval :: id (), boost :: bind ( & method , this , _1 ), exchangeId , symbol , tfTimeframe , timestampInterval , bReturnAllDownloadedData ); Register RegisterDemandCallback < XCandlesGapContainerSimple , stExchangeId , stSymbolPair , TTimeframe , TTimestampInterval , bool > ( MessageType :: ExchangeDataHistoric :: demandDownloadHistoricDataByInterval :: id (), boost :: bind ( & method , this , _1 , _2 , _3 , _4 , _5 , _6 ) ); Handler void method ( Atomix :: MessageBroker :: IDemandEvent < XCandlesGapContainerSimple >* demandEvent , const stExchangeId & exchangeId , const Modules :: Currencies :: stSymbolPair & pair , const TTimeframe & tfTimeframe , const TTimestampInterval & tmTimeInterval , bool bReturnAllDownloadedData ) { }","title":"Demand download historic data by interval"},{"location":"message_broker/exchange-historic-data/#demand-download-historic-data-by-amount","text":"Type: Demand Message: MessageType::ExchangeDataHistoric::demandDownloadHistoricDataByAmount Returns: candles : XCandlesGapContainerSimple Params: stExchangeId exchangeId, const stSymbolPair& symbol, TTimeframe timeframe, TTimestamp timestmap, int nAmount, bool bReturnAllDownloadedData Note: Requires amount data starting by dataTimestamp. For forward pass +amount , for backward -amount Send SendDemand < XCandlesGapContainerSimple , stExchangeId , stSymbolPair , TTimeframe , TTimestamp , int , bool > ( MessageType :: ExchangeDataHistoric :: demandDownloadHistoricDataByAmount :: id (), boost :: bind ( & method , this , _1 ), exchangeId , symbol , tfTimeframe , timestamp , nAmount , bReturnAllDownloadedData ); Register RegisterDemandCallback < XCandlesGapContainerSimple , stExchangeId , stSymbolPair , TTimeframe , TTimestamp , int , bool > ( MessageType :: ExchangeDataHistoric :: demandDownloadHistoricDataByAmount :: id (), boost :: bind ( & method , this , _1 , _2 , _3 , _4 , _5 , _6 , _7 ) ); Handler void method ( Atomix :: MessageBroker :: IDemandEvent < XCandlesGapContainerSimple >* demandEvent , const stExchangeId & exchangeId , const Modules :: Currencies :: stSymbolPair & pair , const TTimeframe & tfTimeframe , const TTimestamp & tmTimestamp , int nAmount , bool bReturnAllDownloadedData ) { }","title":"Demand download historic data by amount"},{"location":"message_broker/exchange-orders/","text":"Exchange Orders Create new order Type: Demand Message: MessageType::ExchangeOrders::demandCreateOrder Returns: stExchangeOrder Params: const XUuid& apiKey, const stExchangeOrderCreate& order Send SendDirectDemand < stExchangeOrder , XUuid , stExchangeOrderCreate > ( MessageType :: ExchangeOrders :: demandCreateOrder :: id (), apiKey , stExchangeOrderCreate () ); Register RegisterDemandCallback < stExchangeOrder , XUuid , stExchangeOrderCreate > ( MessageType :: ExchangeOrders :: demandCreateOrder :: id (), boost :: bind ( & method , this , _1 , _2 ) ); Handler stExchangeOrder method ( const XUuid & apiKey , const stExchangeOrderCreate & order ) { } Cancel order Type: Demand Message: MessageType::ExchangeOrders::demandCancelOrder Returns: stExchangeOrder Params: const XUuid& apiKey, const stExchangeOrderId& orderId Send SendDirectDemand < stExchangeOrder , XUuid , stExchangeOrderId > ( MessageType :: ExchangeOrders :: demandCancelOrder :: id (), apiKey , stExchangeOrderId () ); Register RegisterDemandCallback < stExchangeOrder , XUuid , stExchangeOrderId > ( MessageType :: ExchangeOrders :: demandCancelOrder :: id (), boost :: bind ( & method , this , _1 , _2 ) ); Handler stExchangeOrder method ( const XUuid & apiKey , const stExchangeOrderId & orderId ) { } Cancel all orders Type: Demand Message: MessageType::ExchangeOrders::demandCancelAllOrders Returns: stExchangeOrdersContainer Params: const XUuid& apiKey, const stSymbolPair& symbol Send SendDirectDemand < stExchangeOrdersContainer , XUuid , stSymbolPair > ( MessageType :: ExchangeOrders :: demandCancelAllOrders :: id (), apiKey , symbol ); Register RegisterDemandCallback < stExchangeOrdersContainer , XUuid , stSymbolPair > ( MessageType :: ExchangeOrders :: demandCancelAllOrders :: id (), boost :: bind ( & method , this , _1 , _2 ) ); Handler stExchangeOrdersContainer method ( const XUuid & apiKey , const stSymbolPair & symbol ) { } Request order info Type: Request Message: MessageType::ExchangeOrders::requestGetOrder Returns: stExchangeOrder Params: const XUuid& apiKey, const stExchangeOrderId& orderId Send SendRequest < stExchangeOrder , XUuid , stExchangeOrderId > ( MessageType :: ExchangeOrders :: requestGetOrder :: id (), apiKey , orderId ); Register RegisterRequestCallback < stExchangeOrder , XUuid , stExchangeOrderId > ( MessageType :: ExchangeOrders :: requestGetOrder :: id (), boost :: bind ( & method , this , _1 , _2 ) ); Handler stExchangeOrder method ( const XUuid & apiKey , const stExchangeOrderId & orderId ) { } Notification of orcer change Type: Message Message: MessageType::ExchangeCoins::notifyOrderChanged Params: const XString& strApiKey, const stExchangeOrder& order Send SendMessage < XString , stExchangeOrder > ( MessageType :: ExchangeCoins :: notifyOrderChanged :: id (), boost :: bind ( & method , this , _1 ), strApiKey , order , ); Register RegisterMessageCallback < XString , stExchangeOrder > ( MessageType :: ExchangeCoins :: notifyOrderChanged :: id (), boost :: bind ( & method , this , _1 , _2 ) ); Handler void method ( const XString & strApiKey , const stExchangeOrder & order ) { }","title":"Exchange Orders"},{"location":"message_broker/exchange-orders/#exchange-orders","text":"","title":"Exchange Orders"},{"location":"message_broker/exchange-orders/#create-new-order","text":"Type: Demand Message: MessageType::ExchangeOrders::demandCreateOrder Returns: stExchangeOrder Params: const XUuid& apiKey, const stExchangeOrderCreate& order Send SendDirectDemand < stExchangeOrder , XUuid , stExchangeOrderCreate > ( MessageType :: ExchangeOrders :: demandCreateOrder :: id (), apiKey , stExchangeOrderCreate () ); Register RegisterDemandCallback < stExchangeOrder , XUuid , stExchangeOrderCreate > ( MessageType :: ExchangeOrders :: demandCreateOrder :: id (), boost :: bind ( & method , this , _1 , _2 ) ); Handler stExchangeOrder method ( const XUuid & apiKey , const stExchangeOrderCreate & order ) { }","title":"Create new order"},{"location":"message_broker/exchange-orders/#cancel-order","text":"Type: Demand Message: MessageType::ExchangeOrders::demandCancelOrder Returns: stExchangeOrder Params: const XUuid& apiKey, const stExchangeOrderId& orderId Send SendDirectDemand < stExchangeOrder , XUuid , stExchangeOrderId > ( MessageType :: ExchangeOrders :: demandCancelOrder :: id (), apiKey , stExchangeOrderId () ); Register RegisterDemandCallback < stExchangeOrder , XUuid , stExchangeOrderId > ( MessageType :: ExchangeOrders :: demandCancelOrder :: id (), boost :: bind ( & method , this , _1 , _2 ) ); Handler stExchangeOrder method ( const XUuid & apiKey , const stExchangeOrderId & orderId ) { }","title":"Cancel order"},{"location":"message_broker/exchange-orders/#cancel-all-orders","text":"Type: Demand Message: MessageType::ExchangeOrders::demandCancelAllOrders Returns: stExchangeOrdersContainer Params: const XUuid& apiKey, const stSymbolPair& symbol Send SendDirectDemand < stExchangeOrdersContainer , XUuid , stSymbolPair > ( MessageType :: ExchangeOrders :: demandCancelAllOrders :: id (), apiKey , symbol ); Register RegisterDemandCallback < stExchangeOrdersContainer , XUuid , stSymbolPair > ( MessageType :: ExchangeOrders :: demandCancelAllOrders :: id (), boost :: bind ( & method , this , _1 , _2 ) ); Handler stExchangeOrdersContainer method ( const XUuid & apiKey , const stSymbolPair & symbol ) { }","title":"Cancel all orders"},{"location":"message_broker/exchange-orders/#request-order-info","text":"Type: Request Message: MessageType::ExchangeOrders::requestGetOrder Returns: stExchangeOrder Params: const XUuid& apiKey, const stExchangeOrderId& orderId Send SendRequest < stExchangeOrder , XUuid , stExchangeOrderId > ( MessageType :: ExchangeOrders :: requestGetOrder :: id (), apiKey , orderId ); Register RegisterRequestCallback < stExchangeOrder , XUuid , stExchangeOrderId > ( MessageType :: ExchangeOrders :: requestGetOrder :: id (), boost :: bind ( & method , this , _1 , _2 ) ); Handler stExchangeOrder method ( const XUuid & apiKey , const stExchangeOrderId & orderId ) { }","title":"Request order info"},{"location":"message_broker/exchange-orders/#notification-of-orcer-change","text":"Type: Message Message: MessageType::ExchangeCoins::notifyOrderChanged Params: const XString& strApiKey, const stExchangeOrder& order Send SendMessage < XString , stExchangeOrder > ( MessageType :: ExchangeCoins :: notifyOrderChanged :: id (), boost :: bind ( & method , this , _1 ), strApiKey , order , ); Register RegisterMessageCallback < XString , stExchangeOrder > ( MessageType :: ExchangeCoins :: notifyOrderChanged :: id (), boost :: bind ( & method , this , _1 , _2 ) ); Handler void method ( const XString & strApiKey , const stExchangeOrder & order ) { }","title":"Notification of orcer change"},{"location":"message_broker/exchange-realtime-data/","text":"Exchange Realtime Data Candle Ticker start/stop Type: Message Start: MessageType::ExchangeDataOnline::cmdCandleTickerStart Stop: MessageType::ExchangeDataOnline::cmdCandleTickerStop Params: stExchangeId exchangeId, const stSymbolPair& symbol, timeframe_t timeframe Send SendMessage < stExchangeId , stSymbolPair , timeframe_t > ( MessageType :: ExchangeDataOnline :: cmdCandleTickerStart :: id (), exchangeBinanceId , stSymbolPair ( \"bnb\" , \"btc\" ), timeframe_t ( EnmTimeframe :: Min1 ) ); SendMessage < stExchangeId , stSymbolPair , timeframe_t > ( MessageType :: ExchangeDataOnline :: cmdCandleTickerStop :: id (), exchangeBinanceId , stSymbolPair ( \"bnb\" , \"btc\" ), timeframe_t ( EnmTimeframe :: Min1 ) ); Register RegisterMessageCallback < stExchangeId , stSymbolPair , timeframe_t > ( MessageType :: ExchangeDataOnline :: cmdCandleTickerStart :: id (), boost :: bind ( & method , this , _1 , _2 , _3 ) ); RegisterMessageCallback < stExchangeId , stSymbolPair , timeframe_t > ( MessageType :: ExchangeDataOnline :: cmdCandleTickerStop :: id (), boost :: bind ( & method , this , _1 , _2 , _3 ) ); HighRes Candle Ticker start/stop Type: Message Start: MessageType::ExchangeDataOnline::cmdCandleTickerHigResolutionStart Stop: MessageType::ExchangeDataOnline::cmdCandleTickerHigResolutionStop Params: stExchangeId exchangeId, const stSymbolPair& symbol, timeframe_t timeframe Send SendMessage < stExchangeId , stSymbolPair , timeframe_t > ( MessageType :: ExchangeDataOnline :: cmdCandleTickerHigResolutionStart :: id (), exchangeBinanceId , stSymbolPair ( \"bnb\" , \"btc\" ), timeframe_t ( EnmTimeframe :: Min1 ) ); SendMessage < stExchangeId , stSymbolPair , timeframe_t > ( MessageType :: ExchangeDataOnline :: cmdCandleTickerHigResolutionStop :: id (), exchangeBinanceId , stSymbolPair ( \"bnb\" , \"btc\" ), timeframe_t ( EnmTimeframe :: Min1 ) ); Register RegisterMessageCallback < stExchangeId , stSymbolPair , timeframe_t > ( MessageType :: ExchangeDataOnline :: cmdCandleTickerHigResolutionStart :: id (), boost :: bind ( & method , this , _1 , _2 , _3 ) ); RegisterMessageCallback < stExchangeId , stSymbolPair , timeframe_t > ( MessageType :: ExchangeDataOnline :: cmdCandleTickerHigResolutionStop :: id (), boost :: bind ( & method , this , _1 , _2 , _3 ) ); Candle ticker Ticker message for normal and high-resolution ticker. Type: Message Message: MessageType::ExchangeDataOnline::onCandleTickerTick::id(exchange, symbol, timeframe) Params: tradeData : stTimeCandleStick Register RegisterMessageCallback < stTimeCandleStick > ( MessageType :: ExchangeDataOnline :: onCandleTickerTick :: id ( exchangeId , pair , timeframe ), boost :: bind ( & method , this , _1 ) ); Send SendMessage < stTimeCandleStick > ( MessageType :: ExchangeDataOnline :: onCandleTickerTick :: id ( exchangeId , symbol , timeframe ), dataCandleStick ); Trade Ticker start/stop Type: Message Start: MessageType::ExchangeDataOnline::cmdTradeTickerStart Stop: MessageType::ExchangeDataOnline::cmdTradeTickerStop Params: stExchangeId exchangeId, const stSymbolPair& symbol Send SendMessage < stExchangeId , stSymbolPair > ( MessageType :: ExchangeDataOnline :: cmdTradeTickerStart :: id (), exchangeBinanceId , stSymbolPair ( \"bnb\" , \"btc\" ), ); SendMessage < stExchangeId , stSymbolPair > ( MessageType :: ExchangeDataOnline :: cmdTradeTickerStop :: id (), exchangeBinanceId , stSymbolPair ( \"bnb\" , \"btc\" ), ); Register RegisterMessageCallback < stExchangeId , stSymbolPair > ( MessageType :: ExchangeDataOnline :: cmdTradeTickerStart :: id (), boost :: bind ( & method , this , _1 , _2 ) ); RegisterMessageCallback < stExchangeId , stSymbolPair > ( MessageType :: ExchangeDataOnline :: cmdTradeTickerStop :: id (), boost :: bind ( & method , this , _1 , _2 ) ); Trade ticker Type: Message Message: MessageType::ExchangeDataOnline::onTradeTick::id(exchange, symbol) Params: tradeData : stTimeTradeData Register RegisterMessageCallback < stTimeTradeData > ( MessageType :: ExchangeDataOnline :: onTradeTick :: id ( exchange , pair ), boost :: bind ( & method , this , _1 ) ); Send SendMessage < stTimeTradeData > ( MessageType :: ExchangeDataOnline :: onTradeTick :: id ( exchange , symbol ), dataTradeTick ); Market Ticker start/stop Type: Message Start: MessageType::ExchangeDataOnline::cmdMarketTickerStart Stop: MessageType::ExchangeDataOnline::cmdMarketTickerStop Params: stExchangeId exchangeId Send SendMessage < stExchangeId > ( MessageType :: ExchangeDataOnline :: cmdMarketTickerStart :: id (), exchangeBinanceId ); SendMessage < stExchangeId , stSymbolPair , timeframe_t > ( MessageType :: ExchangeDataOnline :: cmdMarketTickerStop :: id (), exchangeBinanceId ); Register RegisterMessageCallback < stExchangeId > ( MessageType :: ExchangeDataOnline :: cmdMarketTickerStart :: id (), boost :: bind ( & method , this , _1 ) ); RegisterMessageCallback < stExchangeId > ( MessageType :: ExchangeDataOnline :: cmdMarketTickerStop :: id (), boost :: bind ( & method , this , _1 ) ); Market ticker Type: Message Message: MessageType::ExchangeDataOnline::onMarketTick::id(exchange) Params: tradeData : TlstMarketTickers Register RegisterMessageCallback < TlstMarketTickers > ( MessageType :: ExchangeDataOnline :: onMarketTick :: id ( exchange ), boost :: bind ( & method , this , _1 ) ); Send SendMessage < TlstMarketTickers > ( MessageType :: ExchangeDataOnline :: onMarketTick :: id ( exchange ), lstMarketTicks );","title":"Exchange Realtime Data"},{"location":"message_broker/exchange-realtime-data/#exchange-realtime-data","text":"","title":"Exchange Realtime Data"},{"location":"message_broker/exchange-realtime-data/#candle-ticker-startstop","text":"Type: Message Start: MessageType::ExchangeDataOnline::cmdCandleTickerStart Stop: MessageType::ExchangeDataOnline::cmdCandleTickerStop Params: stExchangeId exchangeId, const stSymbolPair& symbol, timeframe_t timeframe Send SendMessage < stExchangeId , stSymbolPair , timeframe_t > ( MessageType :: ExchangeDataOnline :: cmdCandleTickerStart :: id (), exchangeBinanceId , stSymbolPair ( \"bnb\" , \"btc\" ), timeframe_t ( EnmTimeframe :: Min1 ) ); SendMessage < stExchangeId , stSymbolPair , timeframe_t > ( MessageType :: ExchangeDataOnline :: cmdCandleTickerStop :: id (), exchangeBinanceId , stSymbolPair ( \"bnb\" , \"btc\" ), timeframe_t ( EnmTimeframe :: Min1 ) ); Register RegisterMessageCallback < stExchangeId , stSymbolPair , timeframe_t > ( MessageType :: ExchangeDataOnline :: cmdCandleTickerStart :: id (), boost :: bind ( & method , this , _1 , _2 , _3 ) ); RegisterMessageCallback < stExchangeId , stSymbolPair , timeframe_t > ( MessageType :: ExchangeDataOnline :: cmdCandleTickerStop :: id (), boost :: bind ( & method , this , _1 , _2 , _3 ) );","title":"Candle Ticker start/stop"},{"location":"message_broker/exchange-realtime-data/#highres-candle-ticker-startstop","text":"Type: Message Start: MessageType::ExchangeDataOnline::cmdCandleTickerHigResolutionStart Stop: MessageType::ExchangeDataOnline::cmdCandleTickerHigResolutionStop Params: stExchangeId exchangeId, const stSymbolPair& symbol, timeframe_t timeframe Send SendMessage < stExchangeId , stSymbolPair , timeframe_t > ( MessageType :: ExchangeDataOnline :: cmdCandleTickerHigResolutionStart :: id (), exchangeBinanceId , stSymbolPair ( \"bnb\" , \"btc\" ), timeframe_t ( EnmTimeframe :: Min1 ) ); SendMessage < stExchangeId , stSymbolPair , timeframe_t > ( MessageType :: ExchangeDataOnline :: cmdCandleTickerHigResolutionStop :: id (), exchangeBinanceId , stSymbolPair ( \"bnb\" , \"btc\" ), timeframe_t ( EnmTimeframe :: Min1 ) ); Register RegisterMessageCallback < stExchangeId , stSymbolPair , timeframe_t > ( MessageType :: ExchangeDataOnline :: cmdCandleTickerHigResolutionStart :: id (), boost :: bind ( & method , this , _1 , _2 , _3 ) ); RegisterMessageCallback < stExchangeId , stSymbolPair , timeframe_t > ( MessageType :: ExchangeDataOnline :: cmdCandleTickerHigResolutionStop :: id (), boost :: bind ( & method , this , _1 , _2 , _3 ) );","title":"HighRes Candle Ticker start/stop"},{"location":"message_broker/exchange-realtime-data/#candle-ticker","text":"Ticker message for normal and high-resolution ticker. Type: Message Message: MessageType::ExchangeDataOnline::onCandleTickerTick::id(exchange, symbol, timeframe) Params: tradeData : stTimeCandleStick Register RegisterMessageCallback < stTimeCandleStick > ( MessageType :: ExchangeDataOnline :: onCandleTickerTick :: id ( exchangeId , pair , timeframe ), boost :: bind ( & method , this , _1 ) ); Send SendMessage < stTimeCandleStick > ( MessageType :: ExchangeDataOnline :: onCandleTickerTick :: id ( exchangeId , symbol , timeframe ), dataCandleStick );","title":"Candle ticker"},{"location":"message_broker/exchange-realtime-data/#trade-ticker-startstop","text":"Type: Message Start: MessageType::ExchangeDataOnline::cmdTradeTickerStart Stop: MessageType::ExchangeDataOnline::cmdTradeTickerStop Params: stExchangeId exchangeId, const stSymbolPair& symbol Send SendMessage < stExchangeId , stSymbolPair > ( MessageType :: ExchangeDataOnline :: cmdTradeTickerStart :: id (), exchangeBinanceId , stSymbolPair ( \"bnb\" , \"btc\" ), ); SendMessage < stExchangeId , stSymbolPair > ( MessageType :: ExchangeDataOnline :: cmdTradeTickerStop :: id (), exchangeBinanceId , stSymbolPair ( \"bnb\" , \"btc\" ), ); Register RegisterMessageCallback < stExchangeId , stSymbolPair > ( MessageType :: ExchangeDataOnline :: cmdTradeTickerStart :: id (), boost :: bind ( & method , this , _1 , _2 ) ); RegisterMessageCallback < stExchangeId , stSymbolPair > ( MessageType :: ExchangeDataOnline :: cmdTradeTickerStop :: id (), boost :: bind ( & method , this , _1 , _2 ) );","title":"Trade Ticker start/stop"},{"location":"message_broker/exchange-realtime-data/#trade-ticker","text":"Type: Message Message: MessageType::ExchangeDataOnline::onTradeTick::id(exchange, symbol) Params: tradeData : stTimeTradeData Register RegisterMessageCallback < stTimeTradeData > ( MessageType :: ExchangeDataOnline :: onTradeTick :: id ( exchange , pair ), boost :: bind ( & method , this , _1 ) ); Send SendMessage < stTimeTradeData > ( MessageType :: ExchangeDataOnline :: onTradeTick :: id ( exchange , symbol ), dataTradeTick );","title":"Trade ticker"},{"location":"message_broker/exchange-realtime-data/#market-ticker-startstop","text":"Type: Message Start: MessageType::ExchangeDataOnline::cmdMarketTickerStart Stop: MessageType::ExchangeDataOnline::cmdMarketTickerStop Params: stExchangeId exchangeId Send SendMessage < stExchangeId > ( MessageType :: ExchangeDataOnline :: cmdMarketTickerStart :: id (), exchangeBinanceId ); SendMessage < stExchangeId , stSymbolPair , timeframe_t > ( MessageType :: ExchangeDataOnline :: cmdMarketTickerStop :: id (), exchangeBinanceId ); Register RegisterMessageCallback < stExchangeId > ( MessageType :: ExchangeDataOnline :: cmdMarketTickerStart :: id (), boost :: bind ( & method , this , _1 ) ); RegisterMessageCallback < stExchangeId > ( MessageType :: ExchangeDataOnline :: cmdMarketTickerStop :: id (), boost :: bind ( & method , this , _1 ) );","title":"Market Ticker start/stop"},{"location":"message_broker/exchange-realtime-data/#market-ticker","text":"Type: Message Message: MessageType::ExchangeDataOnline::onMarketTick::id(exchange) Params: tradeData : TlstMarketTickers Register RegisterMessageCallback < TlstMarketTickers > ( MessageType :: ExchangeDataOnline :: onMarketTick :: id ( exchange ), boost :: bind ( & method , this , _1 ) ); Send SendMessage < TlstMarketTickers > ( MessageType :: ExchangeDataOnline :: onMarketTick :: id ( exchange ), lstMarketTicks );","title":"Market ticker"},{"location":"message_broker/exchange-synchronous-data/","text":"Exchange Synchronous Data Candle Ticker start/stop Type: Message Start: MessageType::ExchangeDataSynchronous::cmdCandleTickerStart Stop: MessageType::ExchangeDataSynchronous::cmdCandleTickerStop Params: stExchangeId exchangeId, const stSymbolPair& symbol, TTimeframe timeframe Send SendMessage < stExchangeId , stSymbolPair , TTimeframe > ( MessageType :: ExchangeDataSynchronous :: cmdCandleTickerStart :: id (), \"binance\" , stSymbolPair ( \"bnb\" , \"btc\" ), TTimeframe ( EnmTimeframe :: Min1 ) ); SendMessage < stExchangeId , stSymbolPair , TTimeframe > ( MessageType :: ExchangeDataSynchronous :: cmdCandleTickerStop :: id (), \"binance\" , stSymbolPair ( \"bnb\" , \"btc\" ), TTimeframe ( EnmTimeframe :: Min1 ) ); Register RegisterMessageCallback < stExchangeId , Currencies :: stSymbolPair , TTimeframe > ( MessageType :: ExchangeDataSynchronous :: cmdCandleTickerStart :: id (), boost :: bind ( & method , this , _1 , _2 , _3 ) ); RegisterMessageCallback < stExchangeId , Currencies :: stSymbolPair , TTimeframe > ( MessageType :: ExchangeDataSynchronous :: cmdCandleTickerStop :: id (), boost :: bind ( & method , this , _1 , _2 , _3 ) ); Candle ticker Ticker message for normal and high-resolution ticker. Type: Message Message: MessageType::ExchangeDataSynchronous::onCandleTickerTick::id(exchange, symbol, timeframe) Params: tradeData : stTimeCandleStick Register RegisterMessageCallback < stTimeCandleStick > ( MessageType :: ExchangeDataSynchronous :: onCandleTickerTick :: id ( exchange , pair , timeframe ), boost :: bind ( & method , this , _1 ) ); Send SendSynchronousMessage < stTimeCandleStick > ( MessageType :: ExchangeDataSynchronous :: onCandleTickerTick :: id ( exchange , symbol , timeframe ), dataCandleStick ); End Of Tick Message send when new timeframe window is opened Type: Message Message: MessageType::ExchangeDataSynchronous::onCandleTickerEOT::id() Params: timestamp_t Register RegisterMessageCallback < timestamp_t > ( MessageType :: ExchangeDataSynchronous :: onCandleTickerEOT :: id (), boost :: bind ( & method , this , _1 ) ); Send SendSynchronousMessage < timestamp_t > ( MessageType :: ExchangeDataSynchronous :: onCandleTickerEOT :: id (), tmTimestamp );","title":"Exchange Synchronous Data"},{"location":"message_broker/exchange-synchronous-data/#exchange-synchronous-data","text":"","title":"Exchange Synchronous Data"},{"location":"message_broker/exchange-synchronous-data/#candle-ticker-startstop","text":"Type: Message Start: MessageType::ExchangeDataSynchronous::cmdCandleTickerStart Stop: MessageType::ExchangeDataSynchronous::cmdCandleTickerStop Params: stExchangeId exchangeId, const stSymbolPair& symbol, TTimeframe timeframe Send SendMessage < stExchangeId , stSymbolPair , TTimeframe > ( MessageType :: ExchangeDataSynchronous :: cmdCandleTickerStart :: id (), \"binance\" , stSymbolPair ( \"bnb\" , \"btc\" ), TTimeframe ( EnmTimeframe :: Min1 ) ); SendMessage < stExchangeId , stSymbolPair , TTimeframe > ( MessageType :: ExchangeDataSynchronous :: cmdCandleTickerStop :: id (), \"binance\" , stSymbolPair ( \"bnb\" , \"btc\" ), TTimeframe ( EnmTimeframe :: Min1 ) ); Register RegisterMessageCallback < stExchangeId , Currencies :: stSymbolPair , TTimeframe > ( MessageType :: ExchangeDataSynchronous :: cmdCandleTickerStart :: id (), boost :: bind ( & method , this , _1 , _2 , _3 ) ); RegisterMessageCallback < stExchangeId , Currencies :: stSymbolPair , TTimeframe > ( MessageType :: ExchangeDataSynchronous :: cmdCandleTickerStop :: id (), boost :: bind ( & method , this , _1 , _2 , _3 ) );","title":"Candle Ticker start/stop"},{"location":"message_broker/exchange-synchronous-data/#candle-ticker","text":"Ticker message for normal and high-resolution ticker. Type: Message Message: MessageType::ExchangeDataSynchronous::onCandleTickerTick::id(exchange, symbol, timeframe) Params: tradeData : stTimeCandleStick Register RegisterMessageCallback < stTimeCandleStick > ( MessageType :: ExchangeDataSynchronous :: onCandleTickerTick :: id ( exchange , pair , timeframe ), boost :: bind ( & method , this , _1 ) ); Send SendSynchronousMessage < stTimeCandleStick > ( MessageType :: ExchangeDataSynchronous :: onCandleTickerTick :: id ( exchange , symbol , timeframe ), dataCandleStick );","title":"Candle ticker"},{"location":"message_broker/exchange-synchronous-data/#end-of-tick","text":"Message send when new timeframe window is opened Type: Message Message: MessageType::ExchangeDataSynchronous::onCandleTickerEOT::id() Params: timestamp_t Register RegisterMessageCallback < timestamp_t > ( MessageType :: ExchangeDataSynchronous :: onCandleTickerEOT :: id (), boost :: bind ( & method , this , _1 ) ); Send SendSynchronousMessage < timestamp_t > ( MessageType :: ExchangeDataSynchronous :: onCandleTickerEOT :: id (), tmTimestamp );","title":"End Of Tick"},{"location":"message_broker/exchange-time/","text":"Exchange time Current Exchange Time Type: Request Message: MessageType::ExchangeDataOnline::requestExchangeTime Returns: timestamp : TTimestamp Params: stExchangeId exchangeId Send SendRequest < TTimestamp > ( ExchangesData :: MessageType :: ExchangeDataOnline :: requestExchangeTime :: id (), stExchangeId ( \"binance\" ) ); Register RegisterRequestCallback < TTimestamp , stExchangeId > ( MessageType :: ExchangeDataOnline :: requestExchangeTime :: id (), boost :: bind ( & method , this , _1 ) ); Diff exchange time vs local time Type: Request Message: MessageType::ExchangeDataOnline::requestExchangeVsLocalTimeDiff Returns: timeoffset : TTimestamp Params: stExchangeId exchangeId Send SendRequest < TTimestamp > ( ExchangesData :: MessageType :: ExchangeDataOnline :: requestExchangeVsLocalTimeDiff :: id (), stExchangeId ( \"binance\" ) ); Register RegisterRequestCallback < TTimestamp , stExchangeId > ( MessageType :: ExchangeDataOnline :: requestExchangeVsLocalTimeDiff :: id (), boost :: bind ( & method , this , _1 ) );","title":"Exchange time"},{"location":"message_broker/exchange-time/#exchange-time","text":"","title":"Exchange time"},{"location":"message_broker/exchange-time/#current-exchange-time","text":"Type: Request Message: MessageType::ExchangeDataOnline::requestExchangeTime Returns: timestamp : TTimestamp Params: stExchangeId exchangeId Send SendRequest < TTimestamp > ( ExchangesData :: MessageType :: ExchangeDataOnline :: requestExchangeTime :: id (), stExchangeId ( \"binance\" ) ); Register RegisterRequestCallback < TTimestamp , stExchangeId > ( MessageType :: ExchangeDataOnline :: requestExchangeTime :: id (), boost :: bind ( & method , this , _1 ) );","title":"Current Exchange Time"},{"location":"message_broker/exchange-time/#diff-exchange-time-vs-local-time","text":"Type: Request Message: MessageType::ExchangeDataOnline::requestExchangeVsLocalTimeDiff Returns: timeoffset : TTimestamp Params: stExchangeId exchangeId Send SendRequest < TTimestamp > ( ExchangesData :: MessageType :: ExchangeDataOnline :: requestExchangeVsLocalTimeDiff :: id (), stExchangeId ( \"binance\" ) ); Register RegisterRequestCallback < TTimestamp , stExchangeId > ( MessageType :: ExchangeDataOnline :: requestExchangeVsLocalTimeDiff :: id (), boost :: bind ( & method , this , _1 ) );","title":"Diff exchange time vs local time"},{"location":"message_broker/notifications/","text":"Notification Send user notification Type: Message Message: MessageType::Notifications::userNotification Params: XNotification ptrNotification, XNotificationData ptrData Send SendMessage < XNotification , XNotificationData > ( MessageType :: Notifications :: userNotification :: id (), ptrNotification , ptrData ); Register RegisterMessageCallback < XNotification , XNotificationData > ( MessageType :: Notifications :: userNotification :: id (), boost :: bind ( & method , this , _1 , _2 ) );","title":"Notification"},{"location":"message_broker/notifications/#notification","text":"","title":"Notification"},{"location":"message_broker/notifications/#send-user-notification","text":"Type: Message Message: MessageType::Notifications::userNotification Params: XNotification ptrNotification, XNotificationData ptrData Send SendMessage < XNotification , XNotificationData > ( MessageType :: Notifications :: userNotification :: id (), ptrNotification , ptrData ); Register RegisterMessageCallback < XNotification , XNotificationData > ( MessageType :: Notifications :: userNotification :: id (), boost :: bind ( & method , this , _1 , _2 ) );","title":"Send user notification"},{"location":"other/chocolate/","text":"Chocolate Commands List of already installed apps choco list --local-only --idonly","title":"Chocolate"},{"location":"other/chocolate/#chocolate","text":"","title":"Chocolate"},{"location":"other/chocolate/#commands","text":"","title":"Commands"},{"location":"other/chocolate/#list-of-already-installed-apps","text":"choco list --local-only --idonly","title":"List of already installed apps"},{"location":"other/mkdocs/","text":"Basics MkDocs documentation Links For full documentation https://mkdocs.org . Material theme documentation https://squidfunk.github.io/mkdocs-material/ Material theme cheatsheet https://yakworks.github.io/mkdocs-material-components/cheat-sheet/ Nested fence (tabs) documetnation: https://facelessuser.github.io/pymdown-extensions/extensions/superfences How to define tabs in nav: tabs: https://github.com/squidfunk/mkdocs-material/issues/825 Other extensions: https://squidfunk.github.io/mkdocs-material/extensions/codehilite/ including sub-makrdowns: https://stackoverflow.com/questions/35918976/mkdocs-eliminate-copy-paste-in-files Plugins several main directories: https://github.com/spotify/mkdocs-monorepo-plugin Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Basics"},{"location":"other/mkdocs/#basics","text":"","title":"Basics"},{"location":"other/mkdocs/#mkdocs-documentation","text":"","title":"MkDocs documentation"},{"location":"other/mkdocs/#links","text":"For full documentation https://mkdocs.org . Material theme documentation https://squidfunk.github.io/mkdocs-material/ Material theme cheatsheet https://yakworks.github.io/mkdocs-material-components/cheat-sheet/ Nested fence (tabs) documetnation: https://facelessuser.github.io/pymdown-extensions/extensions/superfences How to define tabs in nav: tabs: https://github.com/squidfunk/mkdocs-material/issues/825 Other extensions: https://squidfunk.github.io/mkdocs-material/extensions/codehilite/ including sub-makrdowns: https://stackoverflow.com/questions/35918976/mkdocs-eliminate-copy-paste-in-files","title":"Links"},{"location":"other/mkdocs/#plugins","text":"several main directories: https://github.com/spotify/mkdocs-monorepo-plugin","title":"Plugins"},{"location":"other/mkdocs/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Commands"}]}